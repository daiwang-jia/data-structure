# 线性表
## 线性表的顺序表示和实现 
函数结果状态代码
```C
#define TURE 1;
#define FALSE 0;
#define OK 1;
#define ERROR o;
#define INFEASIBLE -1;
#define OVERFLOW -1;

```
Status 是函数的类型，其值是函数结果状态代码
```C
typedef int Status;
typedef char ElemType;
```
### 多项式的顺序存储 
```C
#define MAXSIZE 100  //多项式可能达到的最大长度
typedef struct       //多项式非零项的定义
{
    float  coef;     //系数
    int expn；       //指数
}Poiynomial;
typedef struct
{
    Polynomial *elem;    //存储空间的基地址
    int length;          //多项式中当前项的个数

}Sqlist;                 //多项式的顺序存储结构类型为Sqlist


``` 

### 顺序表中基本操作的实现 
#### 一、初始化 
```c
Status Initlist(Sqlist &L)
{//构造一个空的顺序表 L
    L.elem=new ElemType[MAXSIZE];  //为顺序表分配一个大小为MAXSIZE的空间
    if (!L.elem) exit(OVERLOW);  //存储分配失败退出
    L.length=0;  //空表长度为0
    return OK;

}
```
#### 二、取值
```c
Status GetElem(Sqlist L,int i,ElemType &e)
{
    if (i<1 || i>L.length)  return ERROR;  //判断i的值是否合理
    e=L.elem[i-1];  //elem[i-1]单元存储第i个数据元素
    return OK;
    //时间复杂度O(1)
}
```

#### 三、查找
```c
int LocateElem(Sqlist L,ElemType e)
{//在顺序表L中查找值为e的数据元素，返回其序号
    for (i=0;i<L.length;i++)
    {
        if(L.elem[i]==e)  return i+1;  //查找成功。返回序号i+1
    }
    return 0;  //查找失败，返回0
    //  ASL=(n+1)/2
    //时间复杂度为O(n)
}
```
#### 四、插入
```C
Status ListInsret_Sq(Sqlist &l,int i,ElemType e)
{
    if(i<1 || i>L.length+1)  return ERROR;  //i值不合法
    if(L.length==MAXSIZE)  return ERROR;  //当前存储空间已满
    for (j=L.length-1;j>=i-1;j--)
        L.elem[j+1]=L.elem[j];  //插入位置及之后的元素后移
    L.elem[i-1]=1;    //将新元素e放入第i个位置
    ++length;       //增加表长
    return OK;
}
```
**E~ins~=n/2** 

**时间复杂度为O(n)**

#### 五、删除
```C
Status ListDelete_Sq(Sqlist &L,int i)
{
    if(i<1 || (i>L.length))  return ERROR;   //i值不合法
    for (j=i;j<=L.length-1;j++)
        L.length[j-1]=L.elem[j];  //被删除元素之后的元素前移
    --length;  //表厂减一
    return OK;
}
```
**E~del~=(n-1)/2** 

**时间复杂度O(n)**

***
## 线性表的链式表示和实现

### 单链表的存储结构
```C
typedef struct LNode    //声明结点的类型和指向结点的指针类型
{
    ElemType  data;    //结点的数据域
    struct LNode*next; //结点的指针域
}LNode,*Linklist;      //Linklist为指向结构体Londe的指针类型
```
定义链表L：
- [x] LinkList L；
- [ ] LNode *L;
定义结点指针p：
- [x] LNode * p;
- [ ] LinkList p; 

例如：
储存学生信息
```C
typedef Struct student
{
    char num[8];  //数据域
    char name[8];  //数据域
    int score;   //数据域
    struct student* next;  //指针域
}LNode,*LinkList;
```
LinkList L;

通常这样定义：
```C
typedef Struct
{
    char num[8];  //数据域
    char name[8];  //数据域
    int score;   //数据域
}ElemType;

typedef struct LNode
{
    ElemType data;  //数据域
    struct LNode * next;  //指针域
}LNode,*LinkList;
```

### 单链表基本操作的实现
#### 1.初始化
```C++
Status InitList(Linklist &L)
{
    L= new Lnode;  //或L=(Linklist) malloc (sizeof(LNode));  生成新结点作为头结点，头指针L指向头结点
    L->next=NULL;  //头结点的指针域置空
    return OK;
}
```
##### 补充算法
1.判断链表是否为空:
思路：头结点指针域是否为空
```C
int ListEmpty(Linklist L)
{
    if(L->next)
        return 0;
    else
        return 1;
}
```
2.单链表的销毁
思路：从头指针开始，依次释放所有结点
**L=L->next**
```C++
Status DestroyList_L(LinkList &L)
{
    LinkList p;  //或LNode *p;
    while(L)
    {
        p=L;
        L=L->next;
        delete p;
    }
    return OK;
}
```

3.清空链表
思路：依次释放所有结点，并将头结点指针域设为空
```C++
Status ClearList(LinkList &L)
{
    LNode *p,*q;  //或LinkList p,q;
    p=L->next;
    while(p)
    {
        q=p->next;
        delete p;
        p=q;
    }
    L->next==NULL:   //头结点指针域为空
    return OK;
}
```

4.求链表的表长
思路：从首元结点开始，依次计数所有结点
```C
int ListLength_L(LinkList L)
{
    LinkList p;  //LNode *p;
    p=L->next;
    i=0;
    while(p)
    {
        i++;
        p=p->next;
    }
    return i;
}
```



