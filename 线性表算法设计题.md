**1.将两个递增的有序链表合并为一个递增的有序链表。要求结果链表仍使用原来的两个链表的存储空间，不另外占用其他的存储空间。表中不允许有重复的数据**
[题目分析]
合并后的新表使用头指针Lc指向，pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点，从第一个结点开始进行比较，当两个链表La和Lb均为到达表尾结点时，依次摘取其中较小者重新链接在Lc表的最后。如果两个表中的元素相等，只摘取La表中的元素，删除Lb表中的元素，这样确保合并后表中无重复的元素。当一个表到达表尾结点，为空时，将非空表的剩余元素直接链接在Lc表的最后。
```c++
void MergeList(LinkList &La,LinkList &Lb,LinkList &Lc)
{//合并链表La和Lb，合并后的新表使用头指针Lc指向
  pa=La->next;  pb=Lb->next;    
   //pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点
   Lc=pc=La;  //用La的头结点作为Lc的头结点
   while(pa && pb)
{if(pa->data<pb->data){pc->next=pa;pc=pa;pa=pa->next;}
     //取较小者La中的元素，将pa链接在pc的后面，pa指针后移
     else if(pa->data>pb->data) {pc->next=pb; pc=pb; pb=pb->next;}
      //取较小者Lb中的元素，将pb链接在pc的后面，pb指针后移
     else //相等时取La中的元素，删除Lb中的元素
{pc->next=pa;pc=pa;pa=pa->next;
      q=pb->next;delete pb ;pb =q;
}
     }
 pc->next=pa?pa:pb;    //插入剩余段
     delete Lb;            //释放Lb的头结点
} 
```  
***
**2.将两个非递减的有序链表合并为一个非递增的有序链表。要求结果链表仍使用原来两个链表的存储空间, 不另外占用其它的存储空间。表中允许有重复的数据。**
[题目分析]
合并后的新表使用头指针Lc指向，pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点，从第一个结点开始进行比较，当两个链表La和Lb均为到达表尾结点时，依次摘取其中较小者重新链接在Lc表的表头结点之后，如果两个表中的元素相等，只摘取La表中的元素，保留Lb表中的元素。当一个表到达表尾结点，为空时，将非空表的剩余元素依次摘取，链接在Lc表的表头结点之后。
```c++
void MergeList(LinkList& La, LinkList& Lb, LinkList& Lc, ) 
{//合并链表La和Lb，合并后的新表使用头指针Lc指向
  pa=La->next;  pb=Lb->next; 
//pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点
  Lc=pc=La; //用La的头结点作为Lc的头结点 
  Lc->next=NULL;
  while(pa||pb )
{//只要存在一个非空表，用q指向待摘取的元素
    if(!pa)  {q=pb;  pb=pb->next;}
//La表为空，用q指向pb，pb指针后移
    else if(!pb)  {q=pa;  pa=pa->next;} 
//Lb表为空，用q指向pa，pa指针后移
    else if(pa->data<=pb->data)  {q=pa;  pa=pa->next;}
//取较小者（包括相等）La中的元素，用q指向pa，pa指针后移
    else {q=pb;  pb=pb->next;}
//取较小者Lb中的元素，用q指向pb，pb指针后移
     q->next = Lc->next;  Lc->next = q;   
//将q指向的结点插在Lc 表的表头结点之后
    }
    delete Lb;             //释放Lb的头结点
}   
```  
***
**3.已知两个链表A和B分别表示两个集合，其元素递增排列。请设计算法求出A与B的交集，并存放于A链表中。**

```c++

```  
***
**4.已知两个链表A和B分别表示两个集合，其元素递增排列。请设计算法求出两个集合A和B 的差集（即仅由在A中出现而不在B中出现的元素所构成的集合），并以同样的形式存储，同时返回该集合的元素个数。**
```c++

```  
***
**5.设计算法将一个带头结点的单链表A分解为两个具有相同结构的链表B、C，其中B表的结点为A表中值小于零的结点，而C表的结点为A表中值大于零的结点（链表A中的元素为非零整数，要求B、C表利用A表的结点）。**
```c++

```  
***  
**6.设计一个算法，通过一趟遍历在单链表中确定值最大的结点。**
```c++

```
***  
**7.设计一个算法，通过遍历一趟，将链表中所有结点的链接方向逆转，仍利用原表的存储空间。**
```c++

```
***  
**8.设计一个算法，删除递增有序链表中值大于mink且小于maxk的所有元素（mink和maxk是给定的两个参数，其值可以和表中的元素相同，也可以不同 ）。**
```c++

``` 
***  
**9.已知p指向双向循环链表中的一个结点，其结点结构为data、prior、next三个域，写出算法change(p),交换p所指向的结点和它的前缀结点的顺序。**
```c++

```
***  
**10.已知长度为n的线性表A采用顺序存储结构，请写一时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除线性表中所有值为item的数据元素。**
```c++

```